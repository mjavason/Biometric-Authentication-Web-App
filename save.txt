function publicKeyBytesConverter(publicKeyBytes: object): string | false {
  // Convert the publicKeyBytes object to a Buffer
  const publicKeyBuffer = Buffer.from(Object.values(publicKeyBytes));

  // Base64 encode the buffer
  const base64PublicKey = base64url.encode(publicKeyBuffer);

  // Check if base64PublicKey is null or empty
  if (!base64PublicKey) return false;

  // PEM format the key
  const publicKeyPem = -----BEGIN PUBLIC KEY-----\n${base64PublicKey
    .match(/.{1,64}/g)!
    .join('\n')}\n-----END PUBLIC KEY-----;

  console.log(publicKeyPem);
  return publicKeyPem;
}

function verify(
  authenticatorDataBase64: any,
  clientDataJSONBase64: any,
  signatureBase64: any,
  publicKeyBytes: any
) {
  // Example input data
  const authenticatorData = Buffer.from(authenticatorDataBase64, 'base64');
  const clientDataJSON = Buffer.from(clientDataJSONBase64, 'base64');
  const signature = Buffer.from(signatureBase64, 'base64');

  // Example public key in PEM format
  //   const publicKeyPem = -----BEGIN PUBLIC KEY-----
  // YOUR_PUBLIC_KEY_HERE
  // -----END PUBLIC KEY-----;

  // Convert clientDataJSON to SHA-256 hash
  const clientDataHash = crypto
    .createHash('sha256')
    .update(clientDataJSON)
    .digest();

  // Concatenate authenticatorData and clientDataHash
  const signedData = Buffer.concat([authenticatorData, clientDataHash]);

  // Verify the signature using the public key
  const verify = crypto.createVerify('SHA256');
  verify.update(signedData);
  verify.end();

  return verify.verify(publicKeyBytes, signature);

  // console.log('Signature is valid:', signatureIsValid);
}
